#include <gtk/gtk.h>
#include <adwaita.h>
#include <gdk/gdkkeysyms.h>  // For keyboard constants, e.g. GDK_KEY_c

#include "toolbar.h"
#include "gtktext_cmark.h" // Markdown processing using cmark
#include "settings.h"

// Forward declarations for functions (if needed, to resolve order dependencies)
// Grouping static functions below, definition before use is preferred.

// --- Begin File I/O Operations ---

/**
 * @brief Determines the full path for the save file.
 * The file is saved as "mini_text_editor.md" in the user's Documents directory.
 * @return A newly allocated string containing the full path, or NULL on failure.
 *         The caller is responsible for freeing the returned string with g_free().
 */
static gchar* get_save_file_path(void) {
    const gchar *doc_dir = g_get_user_special_dir(G_USER_DIRECTORY_DOCUMENTS);
    if (!doc_dir) {
        g_warning("Could not find user's documents directory.");
        return NULL;
    }
    return g_build_filename(doc_dir, "mini_text_editor.md", NULL);
}

/**
 * @brief Loads text content from the predefined save file into the GtkTextBuffer.
 * Parses the content as Markdown.
 * @param buffer The GtkTextBuffer to load the content into.
 */
static void load_markdown_to_buffer(GtkTextBuffer *buffer) {
    g_autofree gchar *filename = get_save_file_path();
    if (!filename) {
        return; // Error already logged by get_save_file_path
    }

    gchar *content = NULL;
    GError *error = NULL;
    g_info("Loading markdown from file: %s", filename);

    if (!g_file_get_contents(filename, &content, NULL, &error)) {
        g_warning("Failed to load file '%s': %s", filename, error ? error->message : "Unknown error");
        g_clear_error(&error);
        // It's okay if the file doesn't exist on first run.
        return;
    }

    g_debug("File contents: %s", content);
    if (!import_markdown_to_buffer_cmark(buffer, content)) {
        g_warning("Failed to import markdown to buffer from file '%s'", filename);
    } else {
        g_info("Successfully loaded and parsed markdown from '%s'", filename);
    }
    g_free(content);
}

/**
 * @brief Saves the content of the GtkTextBuffer to the predefined save file as Markdown.
 * @param buffer The GtkTextBuffer whose content is to be saved.
 */
static void save_buffer_as_markdown(GtkTextBuffer *buffer) {
    g_autofree gchar *filename = get_save_file_path();
    if (!filename) {
        return; // Error already logged
    }

    char *md = export_buffer_to_markdown_cmark(buffer);
    if (!md) {
        g_warning("Failed to export buffer to markdown string.");
        return;
    }

    GError *error = NULL;
    if (!g_file_set_contents(filename, md, -1, &error)) {
        g_warning("Failed to save file '%s': %s", filename, error ? error->message : "Unknown error");
        g_clear_error(&error);
    } else {
        g_info("Successfully saved buffer to '%s'", filename);
    }
    g_free(md);
}

// --- End File I/O Operations ---

// --- Begin Buffer and Editor Event Callbacks ---

/**
 * @brief Callback triggered when the text in the GtkTextBuffer changes.
 * Saves the buffer content as Markdown.
 * @param buffer The GtkTextBuffer that changed.
 * @param user_data User data (unused).
 */
static void on_text_changed(GtkTextBuffer *buffer, G_GNUC_UNUSED gpointer user_data) {
    // Save changes as Markdown
    save_buffer_as_markdown(buffer);
    // Dynamic Markdown parsing/preview was deferred/commented out.
    /*
    if (!markdown_update_pending) {
        markdown_update_pending = TRUE;
        g_idle_add(delayed_markdown_update, text_view);
    }
    */
}

/**
 * @brief Callback triggered when the main window requests to be closed.
 * Saves the current buffer content before allowing the window to close.
 * @param window The GtkWindow being closed (unused).
 * @param user_data The GtkTextView associated with the window.
 * @return GDK_EVENT_PROPAGATE to allow the close operation to proceed after saving.
 */
static gboolean on_window_close_request(G_GNUC_UNUSED GtkWindow *window, gpointer user_data) {
    GtkTextView *text_view = GTK_TEXT_VIEW(user_data);
    GtkTextBuffer *buffer = gtk_text_view_get_buffer(text_view);
    save_buffer_as_markdown(buffer);
    g_info("Content saved on window close request.");
    return GDK_EVENT_PROPAGATE; // Allow the event to propagate (window will close)
}

// --- End Buffer and Editor Event Callbacks ---

// --- Begin Input Handling & Markdown Formatting ---

/**
 * @brief Converts selected text in a GtkTextView to Markdown format and copies it to the clipboard.
 * This function iterates through the selected text, checking for GTK tags (like "bold", "italic", "code", "code-block")
 * and constructs a Markdown string accordingly.
 * @param text_view The GtkTextView containing the selection.
 */
static void copy_selected_text_as_markdown(GtkTextView *text_view) {
    g_debug("copy_selected_text_as_markdown function started");

    GtkTextBuffer *buffer = gtk_text_view_get_buffer(text_view);
    GtkTextIter start, end;

    // Check if there is any selected text
    if (gtk_text_buffer_get_selection_bounds(buffer, &start, &end)) {
        GString *md = g_string_new("");
        GtkTextIter iter = start; // Initialize iterator with the start of selection

        // Flags to track current Markdown state
        gboolean currently_in_italic = FALSE;
        gboolean currently_in_bold = FALSE;
        gboolean currently_in_code = FALSE;
        gboolean currently_in_codeblock = FALSE;
        gboolean at_line_start = gtk_text_iter_starts_line(&iter);

        while (gtk_text_iter_compare(&iter, &end) < 0) {
            // Check tags at the current iterator position
            GSList *tags = gtk_text_iter_get_tags(&iter); // Corrected: Get active tags
            gboolean iter_is_italic = FALSE;
            gboolean iter_is_bold = FALSE;
            gboolean iter_is_code = FALSE;
            gboolean iter_is_codeblock = FALSE;

            for (GSList *l = tags; l != NULL; l = l->next) {
                GtkTextTag *tag_object = GTK_TEXT_TAG(l->data);
                gchar *name_of_tag = NULL;

                // Use g_object_get to retrieve the "name" property as an alternative
                // to gtk_text_tag_get_name, to work around potential compilation issues.
                g_object_get(G_OBJECT(tag_object), "name", &name_of_tag, NULL);

                if (name_of_tag) {
                    if (g_strcmp0(name_of_tag, "italic") == 0) iter_is_italic = TRUE;
                    else if (g_strcmp0(name_of_tag, "bold") == 0) iter_is_bold = TRUE;
                    else if (g_strcmp0(name_of_tag, "code") == 0) iter_is_code = TRUE;
                    else if (g_strcmp0(name_of_tag, "codeblock") == 0) iter_is_codeblock = TRUE;
                    g_free(name_of_tag); // Free the allocated string after use
                }
            }
            g_slist_free_full(tags, g_object_unref); // Free the list of tags

            // Handle transitions for italic
            if (iter_is_italic && !currently_in_italic) {
                g_string_append(md, "*");
                currently_in_italic = TRUE;
            } else if (!iter_is_italic && currently_in_italic) {
                g_string_append(md, "*");
                currently_in_italic = FALSE;
            }

            // Handle transitions for bold
            if (iter_is_bold && !currently_in_bold) {
                g_string_append(md, "**");
                currently_in_bold = TRUE;
            } else if (!iter_is_bold && currently_in_bold) {
                g_string_append(md, "**");
                currently_in_bold = FALSE;
            }
            
            // Handle transitions for inline code (mutually exclusive with code block)
            if (!iter_is_codeblock) { // Only process inline code if not in a code block
                if (iter_is_code && !currently_in_code) {
                    g_string_append(md, "`");
                    currently_in_code = TRUE;
                } else if (!iter_is_code && currently_in_code) {
                    g_string_append(md, "`");
                    currently_in_code = FALSE;
                }
            }


            // Handle transitions for code block
            if (iter_is_codeblock && !currently_in_codeblock) {
                // Starting a code block
                if (at_line_start) { // Ensure ``` is at the beginning of a line
                    g_string_append(md, "```\n");
                } else { // If not at line start, add a newline before ```
                    g_string_append(md, "\n```\n");
                }
                currently_in_codeblock = TRUE;
                // If we were in inline code, terminate it as code block takes precedence
                if (currently_in_code) {
                    // This case might need careful thought: can a selection transition from inline code to code block?
                    // Assuming for now that code-block tag dominates.
                    currently_in_code = FALSE; 
                }
            } else if (!iter_is_codeblock && currently_in_codeblock) {
                // Ending a code block
                if (!at_line_start && md->str[md->len -1] != '\n') { // Corrected: Ensure ``` is on a new line
                    g_string_append(md, "\n");
                }
                g_string_append(md, "```");
                // Add a newline after closing code block if the text continues on the same line in buffer
                // This depends on how the next character is handled.
                // For simplicity, let's assume the next char will handle its own newline if needed.
                currently_in_codeblock = FALSE;
            }

            // Append the current character
            gunichar c = gtk_text_iter_get_char(&iter);
            if (c != 0) { // 0 indicates end of buffer, should not happen if iter < end
                g_string_append_unichar(md, c);
            }

            // Advance the iterator
            gboolean was_at_end_of_iter_processing = gtk_text_iter_is_end(&iter); // Check before advancing
            gboolean ends_line = gtk_text_iter_ends_line(&iter);
            gtk_text_iter_forward_char(&iter);
            
            // Update at_line_start for the next character
            // A character starts a new line if the *previous* character ended a line,
            // and we haven't reached the end of the selection.
            at_line_start = ends_line && !was_at_end_of_iter_processing && gtk_text_iter_compare(&iter, &end) < 0;
        }

        // Close any open tags at the end of the selection
        if (currently_in_italic) g_string_append(md, "*");
        if (currently_in_bold) g_string_append(md, "**");
        if (currently_in_code) g_string_append(md, "`");
        if (currently_in_codeblock) {
            // Ensure the closing ``` is on a new line if necessary
            if (md->len > 0 && md->str[md->len - 1] != '\n') { // Corrected
                g_string_append(md, "\n");
            }
            g_string_append(md, "```");
        }

        // Copy the generated Markdown text to the clipboard
        GdkClipboard *clipboard = gtk_widget_get_clipboard(GTK_WIDGET(text_view));
        gdk_clipboard_set_text(clipboard, md->str);

        g_info("Copied to clipboard as markdown: %s", md->str);

        g_string_free(md, TRUE);
    } else {
        g_debug("No text selection found for markdown copy");
    }
}

/**
 * @brief Callback for keyboard shortcuts, specifically Ctrl+C for custom Markdown copy.
 * @param controller The event controller (unused).
 * @param keyval The pressed key.
 * @param keycode The keycode (unused).
 * @param state Modifier keys state.
 * @param user_data The GtkTextView.
 * @return TRUE if the event was handled, FALSE otherwise.
 */
static gboolean on_key_pressed(G_GNUC_UNUSED GtkEventControllerKey *controller,
                               guint keyval,
                               G_GNUC_UNUSED guint keycode,
                               GdkModifierType state,
                               gpointer user_data) {
    GtkTextView *text_view = GTK_TEXT_VIEW(user_data);

    // Detect Ctrl+C for custom Markdown copy
    if (keyval == GDK_KEY_c && (state & GDK_CONTROL_MASK)) {
        g_debug("Ctrl+C detected, attempting to copy as markdown");
        copy_selected_text_as_markdown(text_view);
        return GDK_EVENT_STOP; // Event handled, stop further processing
    }

    return GDK_EVENT_PROPAGATE; // Pass event to other handlers
}

// --- End Input Handling & Markdown Formatting ---

// --- Begin UI Drawing Helpers (Theme Circles) ---

/** @brief Draws a circle representing the 'System' theme (half black, half white). */
static void draw_system_circle(G_GNUC_UNUSED GtkDrawingArea *area, cairo_t *cr, int w, int h, G_GNUC_UNUSED gpointer user_data) {
    cairo_set_source_rgb(cr, 0, 0, 0); // Black
    cairo_arc(cr, w / 2.0, h / 2.0, MIN(w,h)/2.0 - 2, 0, G_PI); // Top half
    cairo_fill(cr);
    cairo_set_source_rgb(cr, 1, 1, 1); // White
    cairo_arc(cr, w / 2.0, h / 2.0, MIN(w,h)/2.0 - 2, G_PI, 2 * G_PI); // Bottom half
    cairo_fill(cr);
    // Add a border to make it visually distinct if background is also black/white
    cairo_set_source_rgb(cr, 0.5, 0.5, 0.5); // Gray border
    cairo_arc(cr, w / 2.0, h / 2.0, MIN(w,h)/2.0 - 2, 0, 2 * G_PI);
    cairo_set_line_width(cr, 1);
    cairo_stroke(cr);
}

/** @brief Draws a circle representing the 'Light' theme (white with black border). */
static void draw_light_circle(G_GNUC_UNUSED GtkDrawingArea *area, cairo_t *cr, int w, int h, G_GNUC_UNUSED gpointer user_data) {
    cairo_set_source_rgb(cr, 1, 1, 1); // White fill
    cairo_arc(cr, w / 2.0, h / 2.0, MIN(w,h)/2.0 - 2, 0, 2 * G_PI);
    cairo_fill(cr);
    cairo_set_source_rgb(cr, 0, 0, 0); // Black border
    cairo_set_line_width(cr, 1);
    cairo_arc(cr, w / 2.0, h / 2.0, MIN(w,h)/2.0 - 2, 0, 2 * G_PI);
    cairo_stroke(cr);
}

/** @brief Draws a circle representing the 'Dark' theme (black with white border). */
static void draw_dark_circle(G_GNUC_UNUSED GtkDrawingArea *area, cairo_t *cr, int w, int h, G_GNUC_UNUSED gpointer user_data) {
    cairo_set_source_rgb(cr, 0, 0, 0); // Black fill
    cairo_arc(cr, w / 2.0, h / 2.0, MIN(w,h)/2.0 - 2, 0, 2 * G_PI);
    cairo_fill(cr);
    cairo_set_source_rgb(cr, 1, 1, 1); // White border
    cairo_set_line_width(cr, 1);
    cairo_arc(cr, w / 2.0, h / 2.0, MIN(w,h)/2.0 - 2, 0, 2 * G_PI);
    cairo_stroke(cr);
}

// --- End UI Drawing Helpers ---

// --- Begin Settings Menu Callbacks & UI Construction ---

/**
 * @brief Callback for the "About" menu item. Displays an AdwAboutDialog.
 * @param widget The menu item that was clicked (unused, but part of GCallback signature).
 * @param user_data The parent GtkWindow, used for presenting the dialog.
 */
static void on_settings_menu_about(G_GNUC_UNUSED GtkWidget *widget, gpointer user_data) {
    // user_data is the parent window
    GtkWindow *parent_window = GTK_WINDOW(user_data);

    AdwDialog *about_dialog = adw_about_dialog_new(); // Corrected type
    // TODO: Internationalize with _()
    adw_about_dialog_set_application_name(ADW_ABOUT_DIALOG(about_dialog), "Mini Text Editor");
    adw_about_dialog_set_application_icon(ADW_ABOUT_DIALOG(about_dialog), "text-editor-symbolic"); // Example icon name
    adw_about_dialog_set_version(ADW_ABOUT_DIALOG(about_dialog), "1.0");
    // TODO: Internationalize with _()
    adw_about_dialog_set_developer_name(ADW_ABOUT_DIALOG(about_dialog), "Cadric");
    // TODO: Internationalize with _()
    adw_about_dialog_set_copyright(ADW_ABOUT_DIALOG(about_dialog), "© 2023-2025 Cadric");
    // TODO: Internationalize with _()
    adw_about_dialog_set_comments(ADW_ABOUT_DIALOG(about_dialog), "A simple Markdown text editor based on GTK4 and LibAdwaita.");
    adw_about_dialog_set_website(ADW_ABOUT_DIALOG(about_dialog), "https://example.com/mini-text-editor"); // Placeholder
    adw_about_dialog_set_license_type(ADW_ABOUT_DIALOG(about_dialog), GTK_LICENSE_GPL_3_0_ONLY); // Be specific if possible

    // Set parent for the dialog
    gtk_window_set_transient_for(GTK_WINDOW(about_dialog), parent_window);
    gtk_window_set_modal(GTK_WINDOW(about_dialog), TRUE);
    
    adw_dialog_present(ADW_DIALOG(about_dialog), GTK_WIDGET(parent_window)); // Corrected: Cast parent_window
}

/**
 * @brief Callback for the "Settings" menu item. Creates and shows the settings window.
 * @param widget The menu item that was clicked (unused).
 * @param user_data The parent GtkWindow.
 */
static void on_settings_menu_settings(G_GNUC_UNUSED GtkWidget *widget, gpointer user_data) {
    // create_settings_window is expected to handle its own presentation.
    // The returned AdwDialog is marked G_GNUC_UNUSED as it's not used further here.
    G_GNUC_UNUSED AdwDialog *settings_dialog = create_settings_window(GTK_WINDOW(user_data));
    // If create_settings_window doesn't present, it should be done here:
    // if (settings_dialog) {
    //     adw_dialog_present(settings_dialog, GTK_WINDOW(user_data));
    // }
}

/**
 * @brief Callback for theme selection buttons. Sets the Adwaita color scheme.
 * @param widget The GtkButton that was clicked. Theme name is stored in object data.
 * @param user_data User data (unused).
 */
static void on_settings_menu_theme(GtkWidget *widget, G_GNUC_UNUSED gpointer user_data) {
    AdwStyleManager *style_manager = adw_style_manager_get_default();
    const char *button_name = g_object_get_data(G_OBJECT(widget), "theme-name");

    if (button_name == NULL) {
        g_warning("Theme button clicked, but no 'theme-name' data found.");
        return;
    }
    
    AdwColorScheme new_scheme;
    if (g_strcmp0(button_name, "system") == 0) {
        new_scheme = ADW_COLOR_SCHEME_PREFER_LIGHT; // Or FORCE_LIGHT, DEFAULT if system is truly desired behavior
                                                   // ADW_COLOR_SCHEME_DEFAULT might be better for "system"
        g_info("Setting theme to System default.");
        // For true system following, you might need to listen to system changes
        // or rely on Adwaita's default behavior if not explicitly set.
        // For now, let's assume ADW_COLOR_SCHEME_DEFAULT is system.
        new_scheme = ADW_COLOR_SCHEME_DEFAULT;

    } else if (g_strcmp0(button_name, "light") == 0) {
        new_scheme = ADW_COLOR_SCHEME_FORCE_LIGHT;
        g_info("Setting theme to Light.");
    } else if (g_strcmp0(button_name, "dark") == 0) {
        new_scheme = ADW_COLOR_SCHEME_FORCE_DARK;
        g_info("Setting theme to Dark.");
    } else {
        g_warning("Unknown theme name: %s", button_name);
        return;
    }
    adw_style_manager_set_color_scheme(style_manager, new_scheme);
}

/**
 * @brief Creates the header bar menu button and its popover menu.
 * This menu includes theme selection and other settings.
 * @param parent The parent GtkWindow, used for context for dialogs triggered from menu.
 * @return A new GtkWidget (GtkMenuButton) for the header bar.
 */
static GtkWidget* create_header_menu(GtkWindow *parent) {
    GtkWidget *menu_button = gtk_menu_button_new();
    gtk_menu_button_set_icon_name(GTK_MENU_BUTTON(menu_button), "open-menu-symbolic");
    // TODO: Internationalize with _() (Tooltip for menu button)
    gtk_widget_set_tooltip_text(menu_button, "Menu");


    GMenu *menu_model = g_menu_new();
    // Section for themes
    GMenu *theme_submenu = g_menu_new();
    // TODO: Internationalize with _()
    g_menu_append(theme_submenu, "System", "app.theme::system");
    g_menu_append(theme_submenu, "Light", "app.theme::light");
    g_menu_append(theme_submenu, "Dark", "app.theme::dark");
    // TODO: Internationalize with _()
    g_menu_insert_section(menu_model, 0, "Theme", G_MENU_MODEL(theme_submenu)); // Corrected: Cast theme_submenu
    g_object_unref(theme_submenu);

    // Separator
     g_menu_insert_section(menu_model, 1, NULL, NULL); // Creates a separator

    // Other settings
    // TODO: Internationalize with _()
    g_menu_append(menu_model, "Settings", "app.settings");
    // TODO: Internationalize with _()
    g_menu_append(menu_model, "About", "app.about");

    gtk_menu_button_set_menu_model(GTK_MENU_BUTTON(menu_button), G_MENU_MODEL(menu_model));
    g_object_unref(menu_model);

    // Create GSimpleActions for menu items
    // Note: Actions are typically added to the GtkApplication or GtkApplicationWindow
    // For simplicity in this refactor, if actions are not already app-wide,
    // this approach might need adjustment based on where actions are managed.
    // Assuming actions will be connected in app_activate or similar.
    // The original code used direct GtkButton signals for a custom popover.
    // Reverting to the original custom popover structure as GMenu might be too big a change for "refactor only".

    // --- Original Popover Structure (Refactored) ---
    GtkWidget *popover = gtk_popover_new();
    gtk_menu_button_set_popover(GTK_MENU_BUTTON(menu_button), popover);

    GtkWidget *main_vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 6);
    gtk_widget_set_margin_start(main_vbox, 12);
    gtk_widget_set_margin_end(main_vbox, 12);
    gtk_widget_set_margin_top(main_vbox, 12);
    gtk_widget_set_margin_bottom(main_vbox, 12);
    gtk_popover_set_child(GTK_POPOVER(popover), main_vbox);

    // Theme chooser section
    // TODO: Internationalize with _()
    GtkWidget *theme_label = gtk_label_new("Theme");
    gtk_widget_add_css_class(theme_label, "title-4"); // Using a style class for heading
    gtk_widget_set_halign(theme_label, GTK_ALIGN_START);
    gtk_box_append(GTK_BOX(main_vbox), theme_label);
    
    GtkWidget *theme_hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 6);
    gtk_box_set_homogeneous(GTK_BOX(theme_hbox), TRUE); // Make buttons same size
    gtk_widget_set_halign(theme_hbox, GTK_ALIGN_CENTER);
    gtk_box_append(GTK_BOX(main_vbox), theme_hbox);

    const int icon_size = 24;

    // System theme button
    GtkWidget *btn_system = gtk_button_new();
    gtk_button_set_has_frame(GTK_BUTTON(btn_system), FALSE);
    GtkWidget *system_icon = gtk_drawing_area_new();
    gtk_drawing_area_set_content_width(GTK_DRAWING_AREA(system_icon), icon_size);
    gtk_drawing_area_set_content_height(GTK_DRAWING_AREA(system_icon), icon_size);
    gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(system_icon), draw_system_circle, NULL, NULL);
    gtk_button_set_child(GTK_BUTTON(btn_system), system_icon);
    // TODO: Internationalize with _()
    gtk_widget_set_tooltip_text(btn_system, "System Theme");
    g_object_set_data(G_OBJECT(btn_system), "theme-name", "system");
    g_signal_connect(btn_system, "clicked", G_CALLBACK(on_settings_menu_theme), NULL); // Parent not needed for this cb
    gtk_box_append(GTK_BOX(theme_hbox), btn_system);
    
    // Light theme button
    GtkWidget *btn_light = gtk_button_new();
    gtk_button_set_has_frame(GTK_BUTTON(btn_light), FALSE);
    GtkWidget *light_icon = gtk_drawing_area_new();
    gtk_drawing_area_set_content_width(GTK_DRAWING_AREA(light_icon), icon_size);
    gtk_drawing_area_set_content_height(GTK_DRAWING_AREA(light_icon), icon_size);
    gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(light_icon), draw_light_circle, NULL, NULL);
    gtk_button_set_child(GTK_BUTTON(btn_light), light_icon);
    // TODO: Internationalize with _()
    gtk_widget_set_tooltip_text(btn_light, "Light Theme");
    g_object_set_data(G_OBJECT(btn_light), "theme-name", "light");
    g_signal_connect(btn_light, "clicked", G_CALLBACK(on_settings_menu_theme), NULL);
    gtk_box_append(GTK_BOX(theme_hbox), btn_light);
    
    // Dark theme button
    GtkWidget *btn_dark = gtk_button_new();
    gtk_button_set_has_frame(GTK_BUTTON(btn_dark), FALSE);
    GtkWidget *dark_icon = gtk_drawing_area_new();
    gtk_drawing_area_set_content_width(GTK_DRAWING_AREA(dark_icon), icon_size);
    gtk_drawing_area_set_content_height(GTK_DRAWING_AREA(dark_icon), icon_size);
    gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(dark_icon), draw_dark_circle, NULL, NULL);
    gtk_button_set_child(GTK_BUTTON(btn_dark), dark_icon);
    // TODO: Internationalize with _()
    gtk_widget_set_tooltip_text(btn_dark, "Dark Theme");
    g_object_set_data(G_OBJECT(btn_dark), "theme-name", "dark");
    g_signal_connect(btn_dark, "clicked", G_CALLBACK(on_settings_menu_theme), NULL);
    gtk_box_append(GTK_BOX(theme_hbox), btn_dark);

    // Separator
    GtkWidget *separator = gtk_separator_new(GTK_ORIENTATION_HORIZONTAL);
    gtk_box_append(GTK_BOX(main_vbox), separator);
    
    // Settings button
    // TODO: Internationalize with _()
    GtkWidget *settings_button = gtk_button_new_with_label("Preferences");
    gtk_button_set_has_frame(GTK_BUTTON(settings_button), FALSE);
    gtk_widget_set_halign(settings_button, GTK_ALIGN_FILL);
    g_signal_connect(settings_button, "clicked", G_CALLBACK(on_settings_menu_settings), parent);
    gtk_box_append(GTK_BOX(main_vbox), settings_button);

    // About button
    // TODO: Internationalize with _()
    GtkWidget *about_button = gtk_button_new_with_label("About Mini Text Editor");
    gtk_button_set_has_frame(GTK_BUTTON(about_button), FALSE);
    gtk_widget_set_halign(about_button, GTK_ALIGN_FILL);
    g_signal_connect(about_button, "clicked", G_CALLBACK(on_settings_menu_about), parent);
    gtk_box_append(GTK_BOX(main_vbox), about_button);
    
    return menu_button;
}

// --- End Settings Menu Callbacks & UI Construction ---

// --- Begin Application Lifecycle ---

// Forward declaration for setup_markdown_tags if its definition is below app_activate
static void setup_markdown_tags(GtkTextBuffer *buffer);


/**
 * @brief Called when the application is activated.
 * Sets up the main window, text view, buffer, and connects signals.
 * @param application The GApplication instance.
 */
static void app_activate(GApplication *application) {
    GtkApplication *app = GTK_APPLICATION(application);
    AdwApplicationWindow *window = ADW_APPLICATION_WINDOW(adw_application_window_new(app));
    // TODO: Internationalize with _()
    gtk_window_set_title(GTK_WINDOW(window), "Mini Text Editor");
    gtk_window_set_default_size(GTK_WINDOW(window), 800, 600);

    // Main vertical box that will hold all primary UI elements
    GtkWidget *main_vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);

    // Header bar
    AdwHeaderBar *header_bar = ADW_HEADER_BAR(adw_header_bar_new());
    // Add header menu button to the header bar itself
    GtkWidget *header_menu = create_header_menu(GTK_WINDOW(window));
    adw_header_bar_pack_end(header_bar, header_menu);
    // Add header_bar to the top of the main_vbox
    gtk_box_prepend(GTK_BOX(main_vbox), GTK_WIDGET(header_bar));

    // Text view widget (GtkWidget*)
    GtkWidget *text_view_widget = gtk_text_view_new();
    // GtkTextView instance for specific text operations
    GtkTextView *text_view = GTK_TEXT_VIEW(text_view_widget);
    gtk_text_view_set_wrap_mode(text_view, GTK_WRAP_WORD_CHAR);
    gtk_text_view_set_monospace(text_view, TRUE); // Typically Markdown editors use monospace

    // Toolbar (created in toolbar.c, assumed to be added to main_vbox or similar)
    // The toolbar needs the text_view_widget (GtkWidget*) for its actions.
    GtkWidget *toolbar = create_toolbar(text_view_widget);
    gtk_box_append(GTK_BOX(main_vbox), toolbar); // Add toolbar below header_bar

    // Scrolled window for text view
    GtkWidget *scrolled_window = gtk_scrolled_window_new();
    gtk_widget_set_vexpand(scrolled_window, TRUE);
    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scrolled_window), text_view_widget);
    gtk_box_append(GTK_BOX(main_vbox), scrolled_window); // Add scrolled_window (with text_view) below toolbar

    GtkTextBuffer *buffer = gtk_text_view_get_buffer(text_view);
    setup_markdown_tags(buffer); // Setup tags for bold, italic, etc.

    // Load existing content or start fresh
    load_markdown_to_buffer(buffer);

    // Connect signals
    g_signal_connect(buffer, "changed", G_CALLBACK(on_text_changed), NULL);
    g_signal_connect(window, "close-request", G_CALLBACK(on_window_close_request), text_view);

    // Keyboard event controller for Ctrl+C
    GtkEventController *key_controller = gtk_event_controller_key_new();
    g_signal_connect(key_controller, "key-pressed", G_CALLBACK(on_key_pressed), text_view);
    gtk_widget_add_controller(text_view_widget, key_controller);

    // Set the main_vbox (which now contains header, toolbar, and text area) as the content of the AdwApplicationWindow
    adw_application_window_set_content(window, main_vbox);

    // Apply custom CSS if any (example, original was commented out)
    // GtkCssProvider *css_provider = gtk_css_provider_new();
    // gtk_css_provider_load_from_path(css_provider, "styles.css");
    // gtk_style_context_add_provider_for_display(
    //     gdk_display_get_default(),
    //     GTK_STYLE_PROVIDER(css_provider),
    //     GTK_STYLE_PROVIDER_PRIORITY_APPLICATION
    // );
    // g_object_unref(css_provider);

    gtk_window_present(GTK_WINDOW(window));
}

/**
 * @brief Sets up Markdown-related text tags in the GtkTextBuffer.
 * These tags are used for styling and for Markdown export logic.
 * @param buffer The GtkTextBuffer to add tags to.
 */
static void setup_markdown_tags(GtkTextBuffer *buffer) {
    // Bold tag
    gtk_text_buffer_create_tag(buffer, "bold", "weight", PANGO_WEIGHT_BOLD, NULL);
    // Italic tag
    gtk_text_buffer_create_tag(buffer, "italic", "style", PANGO_STYLE_ITALIC, NULL);
    // Monospace / Code tag
    gtk_text_buffer_create_tag(buffer, "code", "family", "monospace", NULL);
    // Code block tag - could also use background, specific font, etc.
    // For simplicity, also monospace. Could have different visual treatment.
    gtk_text_buffer_create_tag(buffer, "code-block", "family", "monospace", "pixels-above-lines", 5, "pixels-below-lines", 5, "wrap-mode", GTK_WRAP_NONE, NULL);
    // Heading tags (example for H1)
    // TODO: Internationalize with _() (tag names if user visible, though not typical)
    gtk_text_buffer_create_tag(buffer, "h1", "scale", PANGO_SCALE_XX_LARGE, "weight", PANGO_WEIGHT_BOLD, NULL);
    gtk_text_buffer_create_tag(buffer, "h2", "scale", PANGO_SCALE_X_LARGE, "weight", PANGO_WEIGHT_BOLD, NULL);
    // ... add more tags as needed (h3, strikethrough, etc.)
    g_info("Markdown text tags set up in buffer.");
}


/**
 * @brief Main entry point for the application.
 * Initializes and runs the GApplication.
 * @param argc Argument count.
 * @param argv Argument vector.
 * @return Application exit status.
 */
int main(int argc, char *argv[]) {
    AdwApplication *app = adw_application_new("com.example.gtktext", G_APPLICATION_DEFAULT_FLAGS); // Corrected: Use G_APPLICATION_DEFAULT_FLAGS
    g_signal_connect(app, "activate", G_CALLBACK(app_activate), NULL);
    int status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);
    return status;
}

// --- End Application Lifecycle ---